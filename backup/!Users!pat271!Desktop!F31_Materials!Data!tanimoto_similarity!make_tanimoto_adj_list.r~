#For organizing results into dataframes
if(!require(tidyverse)){
    install.packages("tidyverse", repos = "http://cran.us.r-project.org")
    library("tidyverse")
}
#For processing fingerprints and computing similarity
Sys.setenv(JAVA_HOME='C:\\Program Files\\Java\\jdk-11.0.2')
if(!require(rJava)){
    install.packages("rJava", repos = "http://cran.us.r-project.org")
    library(rJava)
}
if(!require(rcdk)){
    install.packages("rcdk", repos = "http://cran.us.r-project.org")
    library(rcdk)
}

####################################################################
# Get PubChem fingerprints.
####################################################################
fingerprint = function(smiles_str){
    
    #Get the list of fingerprints.
    atom_containers = parse.smiles(smiles_str)
    saveRDS(atom_containers, file = "atom_containers.rds")
    
    fingerprints = lapply(atom_containers, function(mol){
        cat(".")
        ret_val = NULL
        if(length(mol) > 0){
            ret_val = get.fingerprint(mol, type = "pubchem")
        }
        return(ret_val)
    })
    saveRDS(fingerprints, file = "fingerprints.rds")
    
    #Convert to character.
    fingerprint_strings = lapply(fingerprints, function(fprint){return(as.character(fprint))})
    
    #Return fingerprints.
    return(fingerprint_strings)
}

####################################################################
# Compute similarity between all molecules using Tanimoto on 
# PubChem fingerprints.
# For each molecule, compute its similarity to all other molecules
# and write. This saves memory.
####################################################################
compute_tanimoto_sim = function(dat, n, w, threshold){

    #Read in file and get fingerprint bit vectors.
    fingerprint_vecs = lapply(dat$fingerprint, function(fprint){as.numeric(unlist(strsplit(as.character(fprint),"")))})
    
    #Open output files.
    namefile = file(n, "w")
    weightfile = file(w, "w")
    
    #For each molecule, compute its similarity to all other molecules
    #and write to a file.
    weights_ids = lapply(seq(1,length(fingerprint_vecs)), function(mol){
    
        #Compute all similarities to this molecule.
        sims = lapply(seq(1,length(fingerprint_vecs)), function(mol2){
            sim = 0
            #Simliarity of a molecule to itself is set to 0 so it will be filtered out.
            if (dat$ramp[[mol]] != dat$ramp[[mol2]]){
               sim = tanimoto(fingerprint_vecs[[mol]], fingerprint_vecs[[mol2]]) 
            }
            return(sim)})
            
        #Retain only similarities greater than the threshold.
        weights_keep = unlist(sims[which(sims >= threshold)])
        ids_keep = dat$ramp[which(sims >= threshold)]
        
        #Return ids and weights.
        return(data.frame(as.data.frame(weights_keep), as.data.frame(ids_keep, stringsAsFactors = FALSE)))
    })
    
    #Write all weights and ID's for each molecule.
    sink(namefile)
    for (conn in weights_ids){
        cat(paste0(paste(conn$ids_keep, collapse = ","), "\n"))
    }
    sink()
    sink(weightfile)
    for (conn in weights_ids){
        cat(paste0(paste(conn$weights_keep, collapse = ","), "\n"))
    }
    sink()
    
    #Close files.
    close(namefile)
    close(weightfile)
}

####################################################################
# Computes the Jaccard / Tanimoto similarity between two bit vectors.
####################################################################
tanimoto = function(x, y){
    intersection = length(which((x * y) == 1))
    union1 = length(which(x == 1)) + length(which(y == 1)) - intersection
    return(intersection / union1)
}

###############################################################
# MAIN CODE
# 1. Get ClassyFire classification and compute similarity.
# 2. Get PubChem fingerprints and compute Tanimoto similarity.
# 3. Compute MCS similarity.
###############################################################

#Files
args = commandArgs(trailingOnly=TRUE)
ramp_smiles_all = read.table("C:\\Users\\tarae\\OneDrive\\Documents\\PhD\\Research\\metabolite_network\\hmdb_metabolites\\all_ramp_smiles.tsv", stringsAsFactors = FALSE)
colnames(ramp_smiles_all) = c("ramp", "smiles")

metabolites = read.table(args[1], stringsAsFactors = FALSE, quote = "")
network_names = paste(args[2], paste0("chem_sim_conn_ids", args[4], ".txt"), sep = "\\")
network_weights = paste(args[3], paste0("chem_sim_conn_weights", args[4], ".txt"), sep = "\\")

#Remove duplicates RaMP ID's in file. Keep only the first.
ramp_smiles_unique = distinct(ramp_smiles_all, ramp, .keep_all = TRUE)

#Limit the ramp-to-smiles mapping to include only the given set of metabolites.
metabolite_indices = unlist(lapply(metabolites$V1, function(m){return(which(ramp_smiles_unique$ramp == m))}))
ramp_smiles = ramp_smiles_unique[metabolite_indices,]

#Adding information
fingerprints = fingerprint(ramp_smiles$smiles)
ramp_smiles$fingerprint = fingerprints
saveRDS(ramp_smiles, file = "ramp_smiles.rds")

#Computing similarity metrics
compute_tanimoto_sim(ramp_smiles, network_names, network_weights, 0.6)

